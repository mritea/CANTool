package CanTool;

import java.io.InputStream;
import java.util.logging.Level;
import java.util.logging.Logger;

import gnu.io.SerialPort;
import gnu.io.SerialPortEvent;
import gnu.io.SerialPortEventListener;
import serialPort.SerialTool;

public class SerialListener implements SerialPortEventListener{
	private SerialPort port;
	private String buff;
	private CanTool cantool;
	
	public SerialListener(SerialPort port,CanTool cantool) {
		this.port=port;
		this.cantool=cantool;
	}
	
    /**
     * 关闭串口
     * @param serialport 待关闭的串口对象
     */
    public static void closePort(SerialPort serialPort) {
    	if (serialPort != null) {
    		serialPort.close();
    		serialPort = null;
    	}
    }
	
	 public void serialEvent(SerialPortEvent serialPortEvent) {
	        
	        switch (serialPortEvent.getEventType()) {

	            case SerialPortEvent.BI: // 10 通讯中断
	            	System.out.println("与串口设备通讯中断");
	                break;

	            case SerialPortEvent.OE: // 7 溢位（溢出）错误

	            case SerialPortEvent.FE: // 9 帧错误

	            case SerialPortEvent.PE: // 8 奇偶校验错误

	            case SerialPortEvent.CD: // 6 载波检测

	            case SerialPortEvent.CTS: // 3 清除待发送数据

	            case SerialPortEvent.DSR: // 4 待发送数据准备好了

	            case SerialPortEvent.RI: // 5 振铃指示

	            case SerialPortEvent.OUTPUT_BUFFER_EMPTY: // 2 输出缓冲区已清空
	                break;
	            
	            case SerialPortEvent.DATA_AVAILABLE: // 1 串口存在可用数据
	                
//	                System.out.println("found data");
	                byte[] bytes = null;
	                InputStream in=null;
//	                byte[] data = null; 
	                
	                try {
	                	if (port == null) {
	                    	System.out.println("不存在该串口，监听失败");
	                    }else{
	                    	int temp=in.available();
	                    	                    	
	                    	System.out.println("found data:"+temp);
		                	in=port.getInputStream();
		                	int bufflength=in.available();
		                	in.read(bytes);
		                	cantool.getCommand(bytes);
//		                	for(int i=0;in.available()<0;i++){
//		                		System.out.println("listener:"+i);
//		                		byte c=(byte)in.read();
//		                		if(c=='\r'){
//		                			cantool.getCommand(bytes);
//		                			i=0;
//		                		}else{
//		                			bytes[i]=c;
//		                		}
//		                	}
		                		
//	                    	 data = SerialTool.readFromPort(port);    //读取数据，存入字节数组
//	                         String dataString = buff + new String(data);	//与缓冲区剩余数据合并
//	                         
//	                         String[] elements = null;
//	                         elements = dataString.split("\r");
//	                         int len = elements.length;
//	                         if(dataString.charAt(dataString.length()-1)!='\r')
//	                         {
//	                         	buff = elements[len-1];
//	                         	len--;
//	                         }
//	                         else
//	                         {
//	                         	buff = "";
//	                         }
//	                         for(int i=0;i<len;i++)
//	                         {
//	                         	elements[i] = elements[i] + "\r";
//	                         	cantool.getCommand(elements[i]);
//	                         }
//	                         if(buff.length()>512)
//	                         {
//	                         	System.out.println("buff-fail");
//	                         	buff = "";
//	                         }
	                    }

//	                    
	                } catch (Exception e) {
	                    System.exit(0);
	                }    
	                break;
	        }

	    }


}
